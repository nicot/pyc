#!/usr/bin/python

# P0 ast flattener

from compiler.ast import *
import compiler
import sys
import string

debug = False

# python_ast().flatten(parsedFile)
# takes a parsed python ast and converts it to a flat version
class python_ast:
    flat_ast = Module(None, Stmt([]))
    
    # prints each node in the statement on its own line for readability
    def pretty_print(self, ast):
        if isinstance(ast, Module):    
            print "Module:"
            self.pretty_print(ast.node)
        elif isinstance(ast, Stmt):
            print "  stmt: "
            for node in ast.nodes:                
                print "     ", node

        
    def flatten(self, ast):
        if debug:
            print "starting ast:\n", ast, "\n"
        self.flatten_sub(ast, 0)
        if(debug):
            print "\nfinished flattened ast:\n", self.flat_ast, "\n"
        return self.flat_ast

    # Recursive flattening function
    # takes ast as generated by parser and converts to an unrolled states
    # using temporary variables to do so
    # args: ast - ast to be flattened
    #       tmpNum - num of next tmp var to be used
    #       flat_ast - new flattened ast
    def flatten_sub(self, ast, tmpNum):
        if isinstance(ast, Module):
            self.flatten_sub(ast.node, tmpNum)
            return 0

        elif isinstance(ast,  Stmt):
            for node in ast.nodes:
                tmpNum = self.flatten_sub(node, tmpNum)
                tmpNum += 1
            return tmpNum
            
        elif isinstance(ast, Printnl):
            # get tmp var to be printed
            toPrint = self.flatten_sub(ast.nodes[0], tmpNum)
            # build statement 
            stmt = 'print tmp' + str(toPrint)
            self.flat_ast.node.nodes.append(Printnl([toPrint], None))
            return toPrint

        elif isinstance(ast, Add):
            # get left and right tmp vars
            left = self.flatten_sub(ast.left, tmpNum)
            right = self.flatten_sub(ast.right, left + 1)
            # build statement to add tmp vars
            stmt = 'tmp' + str(right + 1) + ' = tmp' + str(left) + ' + tmp' + str(right)
            self.flat_ast.node.nodes.append(compiler.parse(stmt).node.nodes[0])
            return right + 1

        elif isinstance(ast, UnarySub):
            # get tmp var to be negated
            toNeg = self.flatten_sub(ast.expr, tmpNum)
            stmt = 'tmp' + str(toNeg + 1) + ' = -tmp' + str(toNeg)
            self.flat_ast.node.nodes.append(compiler.parse(stmt).node.nodes[0])
            return toNeg + 1
            
        elif isinstance(ast, CallFunc):
            # CallFunc always refers to an input() in p0
            stmt = 'tmp' + str(tmpNum) + ' = input()'
            self.flat_ast.node.nodes.append(compiler.parse(stmt).node.nodes[0])
            return tmpNum
                
        elif isinstance(ast, Name):
            ast.name = "__"+ast.name
            stmt = 'tmp' + str(tmpNum) + ' = ' + ast.name
            self.flat_ast.node.nodes.append(compiler.parse(stmt).node.nodes[0])
            return tmpNum

        elif isinstance(ast, Assign):
            varName = "__"+ast.nodes[0].name
            # get tmp var containing the value to be assigned (right value)
            right = self.flatten_sub(ast.expr, tmpNum)
            stmt = varName + ' = tmp' + str(right)
            self.flat_ast.node.nodes.append(compiler.parse(stmt).node.nodes[0])
            return right
            
        elif isinstance(ast, Discard):
            self.flatten_sub(ast.expr, tmpNum)
            return tmpNum
        
        elif isinstance(ast, Const):
            stmt = 'tmp' + str(tmpNum) + ' = ' + str(ast.value)
            self.flat_ast.node.nodes.append(compiler.parse(stmt).node.nodes[0])
            return tmpNum
            
        else:
            raise Exception("Error: Unrecognized node type")          
